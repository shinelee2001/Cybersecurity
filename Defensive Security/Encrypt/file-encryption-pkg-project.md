# Secure Package (.pkg) Flow Architecture

## 1. Overview
This project wraps an encrypted `.pak` file, an obfuscated key, and a policy file into a single `.pkg` container.  
A launcher script validates the policy, restores the key, and decrypts the payload.

## 2. Package Structure
The `.pkg` file is a ZIP archive containing:

- `payload.pak`  
  Encrypted file generated by the existing encryption algorithm.
- `key.obf.txt`  
  Obfuscated AES key (Base64 reversed).
- `policy.json`  
  Policy rules (expiry, max openings, etc.).
- `metadata.txt`  
  Optional metadata.

## 3. Key Obfuscation
**Obfuscation (packaging):**
1. Convert AES key bytes → Base64 string  
2. Reverse Base64 string  
3. Save as `key.obf.txt`

**Deobfuscation (launcher):**
1. Read reversed string  
2. Reverse back to original Base64  
3. Decode to AES key bytes  

This prevents plain-text key exposure.

## 4. Package Creation Flow
1. Encrypt input file → produce `payload.pak` and AES key  
2. Obfuscate AES key → write `key.obf.txt`  
3. Generate `policy.json` (expiry, max opens)  
4. Include optional `metadata.txt`  
5. Compress all files into a ZIP and rename to `.pkg`

Output: `filename.pkg`

## 5. Launcher Flow
1. Receive `.pkg` file path  
2. Extract contents to a temporary directory  
3. Load and check `policy.json`
   - Expiry date  
   - Max allowed openings  
4. Restore AES key from `key.obf.txt`  
5. Decrypt `payload.pak` using the restored key  
6. Produce the original file in a temporary location  
7. Auto-open the decrypted file  
8. Update usage count (`.usage.json`)  

## 6. File Association (Optional)
Enable double-click execution of `.pkg`:

